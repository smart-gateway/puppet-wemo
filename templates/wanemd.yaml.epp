<%- | String $uplink_interface,
      String $downlink_interface,
      String $bridge_name,
      String $line_rate,
      Boolean $flush_iptables_forward
| -%>
# HEADER:  This file was autogenerated by Puppet.
# HEADER:  This file can be changed by the user if needed. However
# HEADER:  modification via Puppet is preferred.

# This is the port that the service listens on for commands.
grpc_port: 6201

# These are the uplink and downlink interfaces used for bridging traffic. These are the interfaces to which the shaping
# will be applied.
ul_interface: <%= $uplink_interface %>
dl_interface: <%= $downlink_interface %>

# This is the name of the bridge interface that bridges traffic between the two ports listed above.
bridge_name: <%= $bridge_name %>

# This is the speed of the uplink and downlink interfaces. This is used to set the speed for unshaped traffic and should
# usually be the speed of the interface. Note: You can use this as a default shaped speed, i.e. if you set this to 100mbit
# on a 1gbit interface it will shape all traffic to 100mbit even in the default bootup state.
ul_line_rate: <%= $line_rate %>
dl_line_rate: <%= $line_rate %>

# This is the tc handle for the default queue.
# This value should almost never be changed!
default_queue_handle: 9999

# This is the default logging level. Valid values are
# Panic
# Fatal
# Error
# Warn
# Info
# Debug
# Trace
logging_level: debug

# This is the location of the logs, this should either be set to a path on the file system or to `stdout` which will cause
# logging to be printed to the screen
logging_location: /var/log/wanemd.log
# Max log file size in MB
logging_max_size: 500
# Max number of backups to keep
logging_max_backups: 3
# Max age in days
logging_max_age: 30
# Compress log files
logging_compress: true

# This controls if iptables forward table should be flushed by the `wanemd` process on startup.
flush_iptables_forward: <%= $flush_iptables_forward %>

# Compensation factors are used to adjust the values that are given to `wanemd` to compensate for various conditions such
# as for network overhead if packets are in a tunnel so that the achieved rate is the same as the specified rate rather
# then appearing lower then the specified rate due to overhead caused by additional headers. They are applied as
# real_value * comp_factor_... = applied_value
#comp_factor_latency: 0.0
#comp_factor_jitter: 0.0
#comp_factor_loss: 0.0
#comp_factor_duplication: 0.0
#comp_factor_reorder: 0.0
#comp_factor_corruption: 0.0
#comp_factor_rate: 0.0

# Compensation offsets work similarly but are additive in nature.
# real_value + comp_offset_... = applied_value
#comp_offset_latency: 0.0
#comp_offset_jitter: 0.0
#comp_offset_loss: 0.0
#comp_offset_duplication: 0.0
#comp_offset_reorder: 0.0
#comp_offset_corruption: 0.0
#comp_offset_rate: 0.0
